<?php
class Database
{
	// Singleton object.
	private static $me;

	public $db;
	public $host;
	public $name;
	public $username;
	public $password;
	public $dieOnError;
	public $queries;
	public $result;

	// Singleton constructor
	private function __construct($connect = false)
	{
		$Config = Config::getConfig();
		$this->host       = $Config->dbHost;
		$this->name       = $Config->dbName;
		$this->username   = $Config->dbUsername;
		$this->password   = $Config->dbPassword;
		$this->dieOnError = $Config->dbDieOnError;
		$this->db = false;
		$this->queries = array();
		if($connect === true)
			$this->connect();
	}

	// Waiting for 5.3.0
	public static function __callStatic($name, $args)
	{
		return self::$me->__call($name, $args);
	}

	// Get singleton object
	public static function getDatabase($connect = true)
	{
		if(is_null(self::$me))
			self::$me = new Database($connect);
		return self::$me;
	}

	// Connected to server?
	public function isConnected()
	{
		return is_object($this->db) && get_class($this->db) == 'mysqli';
	}

	// Connected to server and selected database?
	public function databaseSelected()
	{
		if(!$this->isConnected()) return false;
		$result = mysql_list_tables($this->name, $this->db);
		return is_object($result);
	}

	// Connect to server and select a database
	public function connect()
	{
		
		$this->db = new mysqli($this->host,$this->username,$this->password,$this->name) or $this->notify('Failed to connect to server.');
		$this->db->set_charset("utf8") or $this->notify('Failed to load character set utf8.');    
		return $this->isConnected();
	}

	// Send a query to mysql server selected database: TODO prepare args
	public function query($sql, $args_to_prepare = null, $exception_on_missing_args = true)
	{
		if(!$this->isConnected()) $this->connect();
		// Allow for prepared arguments: query("SELECT * FROM table WHERE id = :id", array('id' => $some_val));
		if(is_array($args_to_prepare))
		{
			foreach($args_to_prepare as $name => $val)
			{
				$val = $this->quote($val);
				$sql = str_replace(":$name", $val, $sql, $count);
				if($exception_on_missing_args && (0 == $count))
					throw new Exception(":$name was not found in prepared SQL query.");
			}
			
		}
		$this->queries[] = $sql;
		$this->result = $this->db->query($sql) or $this->notify();
		return $this->result;
	}

	
	// Returns the number of rows.
	public function numRows($arg = null)
	{
		$result = $this->resulter($arg);
		return ($result !== false) ? $result->num_rows : false;
	}

	// Returns true if the result has rows
	public function hasRows($arg = null)
	{
		$result = $this->resulter($arg);
		return is_object($result) && ($result->num_rows > 0);
	}

	// Returns the number of rows affected by the previous operation
	public function affectedRows()
	{
		if(!$this->isConnected()) return false;
		return $this->db->affected_rows;
	}

	// Returns the auto increment ID generated by the previous insert statement
	public function insertId()
	{
		if(!$this->isConnected()) return false;
		$id = $this->db->insert_id;
		if($id === 0 || $id === false)
			return false;
		else
			return $id;
	}

	// Returns a single value.
	public function getValue($arg = null)
	{
		$result = $this->resulter($arg);
// 		return $this->hasRows($result) ? mysql_result($result, 0, 0) : false;
		if ($this->hasRows($result))
		{
			$result->data_seek(0);
			$row = $result->fetch_row();
			return $row[0];
		}
		else
			return false;
	}

	// Returns an array of the first value in each row.
	public function getValues($arg = null)
	{
		$result = $this->resulter($arg);
		if(!$this->hasRows($result)) return array();
		$values = array();
		$result->data_seek(0);
		while($row = $result->fetch_array(MYSQLI_ASSOC))
			$values[] = array_pop($row);
		return $values;
	}

	// Returns the first row.
	public function getRow($arg = null)
	{
		$result = $this->resulter($arg);
		return $this->hasRows() ? $result->fetch_array(MYSQLI_ASSOC) : false;
	}

	// Returns an array of all the rows.
	public function getRows($arg = null)
	{
		$result = $this->resulter($arg);
		if(!$this->hasRows($result)) return array();
		$rows = array();
		$result->data_seek(0);
		while($row = $result->fetch_array(MYSQLI_ASSOC))
			$rows[] = $row;
		return $rows;
	}

	// Escapes a value and wraps it in single quotes.
	public function quote($var)
	{
		if(!$this->isConnected()) $this->connect();
		if ($var=='NULL')
			return $var;
		else
			return "'" . $this->escape($var) . "'";
	}

	// Escapes a value.
	public function escape($var)
	{
		if(!$this->isConnected()) $this->connect();
		return $this->db->real_escape_string($var);
	}

	public function numQueries()
	{
		return count($this->queries);
	}

	public function lastQuery()
	{
		if($this->numQueries() > 0)
			return $this->queries[$this->numQueries() - 1];
		else
			return false;
	}

	private function notify($err_msg = null)
	{
		if($err_msg === null)
		{
			$err_msg = $this->db->error;
		}
		error_log($err_msg);
		if($this->dieOnError === true)
		{
			echo '<div class="message errormsg"><p>' . $err_msg . '</p></div>';
			if(strlen($this->lastQuery()))
			{
				echo '<div class="message errormsg"><p>' . $this->lastQuery() . '</p></div>';
			}
			exit;
		}
	}

	// Takes nothing, a MySQL result, or a query string and returns MySQL result resource or false.
	private function resulter($arg = null)
	{
		if(is_null($arg) && is_object($this->result))
			return $this->result;
		elseif(is_object($arg))
			return $arg;
		elseif(is_string($arg))
		{
			$this->query($arg);
			if(is_object($this->result))
				return $this->result;
			else
				return false;
		}
		else
			return false;
	}
}
?>